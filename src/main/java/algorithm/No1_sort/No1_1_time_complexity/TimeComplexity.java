package algorithm.No1_sort.No1_1_time_complexity;

/**
 * 时间频度
 *
 * 一个算法花费的时间与算法中语句的执行次数成正比。语句执行次数越多，花费的时间也就越多。这个执行次数，就称为语句频度或
 * 时间频度。记为T(n)。举例：
 *
 *         int total = 0;
 *         int end = 100;
 *         // 算法1：使用for循环计算
 *         for (int i = 1; i <= end; i++) {
 *             total += i;
 *         }
 *
 *         // T(n) = n + 1;
 *
 *         // 算法2：直接计算
 *         total = (1 + end) * end / 2;
 *
 *         // T(n) = 1;
 *
 * 时间复杂度
 *
 * 1. 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得
 * 当n趋近于无穷大时，T(n)/f(n)的极限为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))
 * 为算法的渐进时间复杂度，简称时间复杂度。
 * 2. T(n)不同，但时间复杂度可能相同。如：T(n)=n^2+7n+6与T(n)=3n^2+2n+2，二者的T(n)不同，但时间复杂度相同，都是
 * O(n^2)。
 * 3. 计算时间复杂度的方法：
 *     1）用常数1代替运行时间中的所有加法常数
 *     2）修改后的运行次数函数中，只保留最高阶项
 *     3）去除最高阶项的系数
 *
 *  常见的时间复杂度
 *      1. 常数阶：O(1)
 *      2. 对数阶：O(㏒₂n)
 *      3. 线性阶：O(n)
 *      4. 线性对数阶：O(n㏒₂n)
 *      5. 平方阶：O(n^2)
 *      6. 立方阶：O(n^3)
 *      7. k次方阶：O(n^k)
 *      8. 指数阶：O(2^n)
 *
 *  以上时间复杂度从小到大依次上升。
 *
 *  平均时间复杂度和最坏时间复杂度
 *  1. 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
 *  2. 最坏时间复杂度是指在最坏情况下的时间复杂度。一般讨论的时间复杂度都是最坏时间复杂度。
 *  3. 平均时间复杂度和最坏时间复杂度是否相同，和算法有关。
 *
 *  排序算法    平均时间    最差情形    是否稳定    额外空间    备注
 *    冒泡        O(n^2)     O(n^2)     是        O(1)       n小时较好
 *    交换        O(n^2)     O(n^2)     否        O(1)       n小时较好
 *    选择        O(n^2)     O(n^2)     否        O(1)       n小时较好
 *    插入        O(n^2)     O(n^2)     是        O(1)       大部分已排序时较好
 *    基数        O(㏒RB)    O(n^2)     是        O(n)       B是真数（0-9），R是基数（个十百）
 *    希尔        O(n^2)     O(n^2)     否        O(1)       n小时较好
 *    快速        O(n^2)     O(n^2)     否        O(1)       n小时较好
 *    归并        O(n^2)     O(n^2)     否        O(1)       n小时较好
 *    堆          O(n^2)     O(n^2)     否        O(1)       n小时较好
 *
 */
public class TimeComplexity {
    public static void main(String[] args) {
        int n = 10;

        //1. 常数阶：O(1)
        m1(n);

        //2. 对数阶：O(㏒₂n)
        m2(n);

        //3. 线性阶：O(n)
        m3(n);

        //4. 线性对数阶：O(n㏒₂n)
        m4(n);

        //5. 平方阶：O(n^2)
        m5(n);

        //6. 立方阶：O(n^3) 参考m5

        //7. k次方阶：O(n^k) 参考m5

        //8. 指数阶：O(2^n)
    }

    //5. 平方阶：O(n^2)
    private static void m5(int n) {
        // 双层循环
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {

            }
        }
    }

    //4. 线性对数阶：O(n㏒₂n)
    private static void m4(int n) {
        int i;
        // 可以理解为，将时间复杂度为㏒₂n的算法，又循环执行了n遍
        for (int m = 0; m < n; m++) {
            i = 1;
            while (i < n) {
                i *= 2;
            }
        }
    }

    //3. 线性阶：O(n)
    private static void m3(int n) {
        int total = 0;
        int start = 1;
        for (int i = start; i <= n; i++) {
            total += i;
        }
    }

    //2. 对数阶：O(㏒₂n)
    private static void m2(int n) {
        int i = 1;
        while (i < n) {
            // 此处 *= 3时，时间复杂度为O(㏒₃n)，以此类推
            i *= 2;
        }
    }

    //1. 常数阶：O(1)
    private static void m1(int n) {
        int total = (1 + n) * n / 2;
    }
}
